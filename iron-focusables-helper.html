<!doctype html>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">

<script>
  (function() {
    'use strict';

    Polymer.IronFocusablesHelper = {
      /**
       * Returns the first and last tabbable nodes, excluding the root node.
       * It searches the tabbable nodes in the light and shadow dom of the chidren,
       * sorting the result by tabindex.
       * @param {!Node} node
       * @return {Array<HTMLElement>}
       */
      getTabbableNodes: function(node) {
        var tabbables = _getTabbableNodes(node);
        return tabbables ? _getFirstLastTabbables(tabbables) : [];
      }
    };

    var isNativeShadowDOM = !window.ShadyDOM && !!Element.prototype.attachShadow;

    function _getTabbableNodes(root) {
      // Handle only Element and DocumentFragments.
      if (root.nodeType !== Node.ELEMENT_NODE && root.nodeType !== Node.DOCUMENT_FRAGMENT_NODE)
        return null;
      // Skip all tabbables inside a shadowRoot if element has tabindex = -1.
      if (isNativeShadowDOM && root.shadowRoot && root.getAttribute('tabindex') === '-1')
        return null;

      // Special treatment for <slot>, as we cannot use tree walkers for distributed content ;_;
      if (isNativeShadowDOM && root.tagName === 'SLOT') {
        var nodes = root.assignedNodes({
          flatten: true
        });
        var tabbables = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
          var node = nodes[i];
          node._tabbables = _getTabbableNodes(node);
          // Keep reference of this node in the slot's _tabbables.
          if (node.tabIndex >= 0 || node._tabbables) {
            _updateFirstLast(node, tabbables);
          }
        }
        return tabbables.length ? tabbables : null;
      }

      var startNode = isNativeShadowDOM && root.shadowRoot ? root.shadowRoot : root;
      var walker = document.createTreeWalker(startNode, NodeFilter.SHOW_ELEMENT, {
        acceptNode: _shouldAcceptNode
      }, false);

      var tabbables = [];
      while (walker.nextNode()) {
        _updateFirstLast(walker.currentNode, tabbables);
      }
      return tabbables.length ? tabbables : null;
    }

    function _getFirstLastTabbables(tabbables) {
      // Get deepest first & last tabbables.
      var first = tabbables[0];
      while (first && first._tabbables) {
        first = first._tabbables[0];
      }
      var last = tabbables[tabbables.length - 1];
      while (last && last._tabbables) {
        last = last._tabbables[last._tabbables.length - 1];
      }
      return last !== first ? [first, last] : [first];
    }

    function _shouldAcceptNode(element) {
      if (isNativeShadowDOM && element.shadowRoot || element.tagName === 'SLOT') {
        element._tabbables = _getTabbableNodes(element);
        return element._tabbables ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
      }
      return element.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }

    function _updateFirstLast(element, result) {
      // The first tabbable is the first node with tabindex 1 or 0.
      // The last tabbable is the last node with tabindex 0.
      var tabIndex = Math.max(element.tabIndex, 0);
      var first = result[0];
      var last = result[result.length - 1];
      if (!first) {
        // First insertion into the result.
        result.push(element);
      } else if (first.tabIndex !== 1 && tabIndex === 1) {
        // A new first!
        result.splice(0, 0, element);
      } else if (result.length > 1 && (tabIndex === 0 || (last.tabindex > 0 && last.tabindex < tabIndex))) {
        // A new last!
        result.push(element);
      } else {
        // Insert before last element.
        // TODO(valdrin) maybe we can skipe these and not pollute the array.
        result.splice(Math.max(result.length - 1, 1), 0, element);
      }
    }
  })();
</script>